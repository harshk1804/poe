



































































Experiment_Steps.txt
---------------------

### Experiment 1: Git Branching & Merging

# Create and switch to a new branch
git checkout -b feature-branch-01

# (Make your code changes, e.g., edit file.txt)
echo "My new feature" > file.txt
git add .
git commit -m "Added new feature"

# Push the new branch to the remote (GitHub)
git push origin feature-branch-01

# (Go to GitHub UI, create a Pull Request from 'feature-branch-01' to 'main', and merge it)

# Switch back to the main branch locally
git checkout main

# Pull the merged changes from the remote
git pull origin main

---

### Experiment 2: Git Hard & Soft Resets

# Create some commit history
echo "Commit A" > reset_demo.txt
git add .
git commit -m "Commit A"
echo "Commit B" > reset_demo.txt
git add .
git commit -m "Commit B"
echo "Commit C" > reset_demo.txt
git add .
git commit -m "Commit C"

# Check log
git log --oneline

# --- Soft Reset ---
# Resets the commit history, but keeps changes staged
git reset --soft HEAD~1
git status
# (You will see 'reset_demo.txt' staged with "Commit C" content)
git log --oneline
# (You will see "Commit C" is gone from the log)

# Re-commit the changes
git commit -m "New Commit C (after soft reset)"

# --- Hard Reset ---
# Create another commit
echo "Commit D" > reset_demo.txt
git add .
git commit -m "Commit D"
git log --oneline

# Resets history AND discards all local changes
git reset --hard HEAD~1
git status
# (You will see working directory is clean)
cat reset_demo.txt
# (Content will be from "New Commit C")
git log --oneline
# (You will see "Commit D" is gone)

# Force push to update remote (use with caution!)
git push origin main --force

---

### Experiment 3: GitHub to GitLab Integration

# Clone the existing GitHub repo
git clone https://github.com/YOUR_USERNAME/YOUR_GITHUB_REPO.git
cd YOUR_GITHUB_REPO

# (Make changes locally if desired)
echo "Change for GitLab" >> README.md
git add .
git commit -m "Updating for GitLab migration"

# (Go to GitLab and create a new, blank project named 'your-gitlab-repo')

# Add GitLab as a new remote
git remote add gitlab https://gitlab.com/YOUR_USERNAME/your-gitlab-repo.git

# Push all branches and tags to the new GitLab remote
git push -u gitlab --all
git push -u gitlab --tags

---

### Experiment 4: GitLab to Bitbucket Integration

# Clone the existing GitLab repo
git clone https://gitlab.com/YOUR_USERNAME/YOUR_GITLAB_REPO.git
cd YOUR_GITLAB_REPO

# (Make changes locally)
echo "Change for Bitbucket" >> README.md
git add .
git commit -m "Updating for Bitbucket migration"

# (Go to Bitbucket and create a new, blank repository named 'your-bitbucket-repo')

# Update the 'origin' remote URL to point to Bitbucket
git remote set-url origin https://YOUR_USERNAME@bitbucket.org/YOUR_USERNAME/your-bitbucket-repo.git

# Push all branches and tags to the Bitbucket remote
git push -u origin --all
git push -u origin --tags

---

### Experiment 5: Merge Conflict Resolution

# From main, create and check out branch A
git checkout main
git checkout -b branch-A

# Make a change in branch A
echo "This is line 1 from Branch A" > conflict.txt
git add .
git commit -m "Branch A change"

# Go back to main, create and check out branch B
git checkout main
git checkout -b branch-B

# Make a conflicting change in branch B
echo "This is line 1 from Branch B" > conflict.txt
git add .
git commit -m "Branch B change"

# Go back to main and merge branch A (this will work)
git checkout main
git merge branch-A

# Try to merge branch B (this will fail)
git merge branch-B
# (You will see a merge conflict error)

# Open 'conflict.txt' in a text editor
# Manually edit the file to resolve the conflict
# (e.g., delete the <<<<, ===, >>>> markers and keep/combine the lines you want)
# Example resolved content:
# "This is the final resolved line"

# Save the file, then add and commit the resolution
git add conflict.txt
git commit -m "Resolved merge conflict between A and B"

---

### Experiment 6: Basic Jenkins Pipeline

# 1. In Jenkins UI: New Item -> Pipeline -> Name: basic-website-pipeline
# 2. Go to the "Pipeline" section
# 3. Select "Pipeline script" from the Definition dropdown
# 4. Paste this Groovy script into the text box:

pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                echo 'Building website...'
                sh 'echo "<html><body><h1>Hello from Basic Jenkins Pipeline</h1></body></html>" > index.html'
            }
        }
        stage('Deploy') {
            steps {
                echo 'Deploying website...'
                // This step is a placeholder. A real deploy might be:
                // sh 'scp index.html user@your-server:/var/www/html/'
                echo 'Deployment complete.'
            }
        }
    }
}

# 5. Click Save, then click "Build Now"

---

### Experiment 7: Containerized Jenkins Pipeline

# 1. In Jenkins UI: New Item -> Pipeline -> Name: containerized-website-pipeline
# 2. Go to the "Pipeline" section
# 3. Select "Pipeline script" from the Definition dropdown
# 4. Paste this Groovy script (requires Docker to be installed on Jenkins agent):

pipeline {
    agent {
        docker { image 'node:16-alpine' }
    }
    stages {
        stage('Verify Environment') {
            steps {
                echo 'Running inside a container'
                sh 'node --version'
                sh 'npm --version'
            }
        }
        stage('Build') {
            steps {
                echo 'Building website...'
                sh 'echo "<html><body><h1>Hello from Containerized Pipeline</h1></body></html>" > index.html'
            }
        }
        stage('Archive') {
            steps {
                // Save the built file as an artifact
                archiveArtifacts artifacts: 'index.html', fingerprint: true
            }
        }
    }
}

# 5. Click Save, then click "Build Now"

---

### Experiment 8: Custom Docker Image (httpd)

# Create a new directory
mkdir my-apache-image
cd my-apache-image

# Create a custom HTML file
echo "<html><body><h1>My Custom Apache Website</h1></body></html>" > index.html

# Create a Dockerfile
echo "FROM httpd:2.4" > Dockerfile
echo "COPY ./index.html /usr/local/apache2/htdocs/" >> Dockerfile

# Build the Docker image
docker build -t YOUR_DOCKERHUB_USERNAME/my-custom-httpd:1.0 .

# Test the image locally
docker run -d -p 8080:80 --name my-test-server YOUR_DOCKERHUB_USERNAME/my-custom-httpd:1.0

# (Open http://localhost:8080 in your browser to see your page)

# Stop and remove the test container
docker stop my-test-server
docker rm my-test-server

# Log in to DockerHub
docker login

# Push the image to DockerHub
docker push YOUR_DOCKERHUB_USERNAME/my-custom-httpd:1.0

---

### Experiment 9: Maven Calculator App

# Generate a new Maven project
mvn archetype:generate -DgroupId=com.example -DartifactId=my-calculator -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false

# Navigate into the project
cd my-calculator

# Create the Calculator class
mkdir -p src/main/java/com/example
echo "package com.example;
public class Calculator {
    public int add(int a, int b) { return a + b; }
    public int subtract(int a, int b) { return a - b; }
}" > src/main/java/com/example/Calculator.java

# Update the App class to use the Calculator
echo "package com.example;
public class App {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(\\"5 + 3 = \\" + calc.add(5, 3));
        System.out.println(\\"5 - 3 = \\" + calc.subtract(5, 3));
    }
}" > src/main/java/com/example/App.java

# Update the JUnit test
echo "package com.example;
import static org.junit.Assert.assertEquals;
import org.junit.Test;
public class AppTest {
    @Test
    public void testAdd() {
        Calculator calc = new Calculator();
        assertEquals(8, calc.add(5, 3));
    }
    @Test
    public void testSubtract() {
        Calculator calc = new Calculator();
        assertEquals(2, calc.subtract(5, 3));
    }
}" > src/test/java/com/example/AppTest.java

# Package the application (this will also run the tests)
mvn package

# Run the packaged application
java -cp target/my-calculator-1.0-SNAPSHOT.jar com.example.App

---

### Experiment 10: Kubernetes with Minikube

# Start Minikube
minikube start

# Create a Kubernetes Deployment
# This pulls a simple "echoserver" image and creates a Pod
kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.4

# Check the status of the deployment
kubectl get deployments

# Check the Pods
kubectl get pods

# Expose the Deployment as a Service to access it
kubectl expose deployment hello-minikube --type=NodePort --port=8080

# Check the Service
kubectl get services

# Get the URL to access the service
minikube service hello-minikube --url

# (Open the provided URL in your browser to see the echoserver response)

# --- Management ---

# Scale the deployment to 3 replicas
kubectl scale deployment/hello-minikube --replicas=3
kubectl get pods

# --- Cleanup ---

# Delete the Service
kubectl delete service hello-minikube

# Delete the Deployment
kubectl delete deployment hello-minikube

# Stop Minikube
minikube stop
